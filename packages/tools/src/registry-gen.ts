#!/usr/bin/env node
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

type RegistryDomain =
  | 'Card'
  | 'Asset'
  | 'VFX'
  | 'Status'
  | 'Car'
  | 'Deck'
  | 'Track'
  | 'Net';

type RegistryEntry = {
  id: number;
  key: string;
  status: 'active' | 'retired';
  notes?: string;
};

type RegistryLock = {
  domain: RegistryDomain;
  range: { start: number; end: number };
  entries: RegistryEntry[];
};

const ENTITY_DOMAINS = ['Card', 'Status', 'Car', 'Deck', 'Track'] as const satisfies RegistryDomain[];
const ASSET_DOMAINS = ['Asset', 'VFX'] as const satisfies RegistryDomain[];
const NET_DOMAINS = ['Net'] as const satisfies RegistryDomain[];

const DOMAIN_RANGES = {
  Card: { start: 1000, end: 1999 },
  Asset: { start: 2000, end: 2999 },
  VFX: { start: 3000, end: 3999 },
  Status: { start: 4000, end: 4999 },
  Car: { start: 5000, end: 5999 },
  Deck: { start: 6000, end: 6999 },
  Track: { start: 7000, end: 7999 },
  Net: { start: 8000, end: 8999 }
} as const;

const moduleDir = path.dirname(fileURLToPath(new URL(import.meta.url)));
const repoRoot = path.resolve(moduleDir, '..', '..', '..');
const locksDir = path.join(repoRoot, 'packages', 'registry', 'locks');
const generatedDir = path.join(repoRoot, 'packages', 'registry', 'src', 'generated');

const GENERATED_HEADER = `/* eslint-disable */\n// Auto-generated by packages/tools/src/registry-gen.ts. Do not edit directly.\n\n`;

async function ensureDir(dirPath: string) {
  await mkdir(dirPath, { recursive: true });
}

function isMissingFileError(error: unknown): error is NodeJS.ErrnoException {
  return Boolean(error && typeof error === 'object' && 'code' in error && (error as NodeJS.ErrnoException).code === 'ENOENT');
}

async function loadLock(domain: RegistryDomain): Promise<RegistryLock> {
  const lockPath = path.join(locksDir, `${domain}.json`);
  const expectedRange = DOMAIN_RANGES[domain];

  try {
    const contents = await readFile(lockPath, 'utf8');
    const parsed = JSON.parse(contents) as RegistryLock;

    if (parsed.domain !== domain) {
      throw new Error(`Lock domain mismatch: expected ${domain} but found ${parsed.domain}`);
    }

    if (parsed.range.start !== expectedRange.start || parsed.range.end !== expectedRange.end) {
      throw new Error(`Lock range mismatch for ${domain}. Expected ${expectedRange.start}-${expectedRange.end}.`);
    }

    parsed.entries.sort((a, b) => a.id - b.id);
    return parsed;
  } catch (error: unknown) {
    if (isMissingFileError(error)) {
      return { domain, range: expectedRange, entries: [] } satisfies RegistryLock;
    }

    throw error;
  }
}

function entryLiteral(entry: RegistryEntry): string {
  const notePart = entry.notes ? `, notes: ${JSON.stringify(entry.notes)}` : '';
  return `{ id: ${entry.id}, key: ${JSON.stringify(entry.key)}, status: '${entry.status}'${notePart} }`;
}

function entriesLiteral(entries: RegistryEntry[]): string {
  if (entries.length === 0) {
    return '[]';
  }

  const parts = entries.map((entry) => `  ${entryLiteral(entry)}`);
  return `[` + (parts.length > 0 ? `\n${parts.join(',\n')}\n` : '') + `]`;
}

function registryLiteral(lock: RegistryLock): string {
  return `{
  domain: '${lock.domain}',
  range: { start: ${lock.range.start}, end: ${lock.range.end} },
  entries: ${entriesLiteral(lock.entries)}
}`;
}

async function writeFileIfChanged(filePath: string, contents: string) {
  const existing = await readFile(filePath, 'utf8').catch((error: unknown) => {
    if (isMissingFileError(error)) {
      return null;
    }
    throw error;
  });

  if (existing === contents) {
    return;
  }

  await writeFile(filePath, contents, 'utf8');
  console.log(`Updated ${path.relative(repoRoot, filePath)}`);
}

function generateEntitiesContent(locks: RegistryLock[]): string {
  const fileBody = ENTITY_DOMAINS.map((domain) => {
    const lock = locks.find((item) => item.domain === domain)!;
    const constName = `${domain.toLowerCase()}Registry`;
    return `export const ${constName} = ${registryLiteral(lock)} satisfies DomainRegistry<'${domain}'>;`;
  }).join('\n\n');

  const exportLines = ENTITY_DOMAINS.map((domain) => `  ${domain.toLowerCase()}: ${domain.toLowerCase()}Registry`).join(',\n');

  return [
    `${GENERATED_HEADER}import type { DomainRegistry } from '../types.js';`,
    '',
    fileBody,
    '',
    'export const entityRegistries = {',
    exportLines,
    "} satisfies Record<'card' | 'status' | 'car' | 'deck' | 'track', DomainRegistry>;",
    ''
  ].join('\n');
}

function generateAssetsContent(locks: RegistryLock[]): string {
  const fileBody = ASSET_DOMAINS.map((domain) => {
    const lock = locks.find((item) => item.domain === domain)!;
    const constName = `${domain.toLowerCase()}Registry`;
    return `export const ${constName} = ${registryLiteral(lock)} satisfies DomainRegistry<'${domain}'>;`;
  }).join('\n\n');

  const exportLines = ASSET_DOMAINS.map((domain) => `  ${domain.toLowerCase()}: ${domain.toLowerCase()}Registry`).join(',\n');

  return [
    `${GENERATED_HEADER}import type { DomainRegistry } from '../types.js';`,
    '',
    fileBody,
    '',
    'export const assetRegistries = {',
    exportLines,
    "} satisfies Record<'asset' | 'vfx', DomainRegistry>;",
    ''
  ].join('\n');
}

function generateNetContent(locks: RegistryLock[]): string {
  const lock = locks.find((item) => item.domain === 'Net')!;
  return [
    `${GENERATED_HEADER}import type { DomainRegistry } from '../types.js';`,
    '',
    `export const netRegistry = ${registryLiteral(lock)} satisfies DomainRegistry<'Net'>;`,
    ''
  ].join('\n');
}

function generateLookupTables(locks: RegistryLock[]): string {
  const entriesWithDomain = locks.flatMap((lock) =>
    lock.entries.map((entry) => ({ ...entry, domain: lock.domain }))
  );

  const byIdLiteral = entriesWithDomain.length === 0
    ? '{}'
    : `{
${entriesWithDomain
        .map((entry) => `  ${entry.id}: { domain: '${entry.domain}', key: ${JSON.stringify(entry.key)}, status: '${entry.status}'${
          entry.notes ? `, notes: ${JSON.stringify(entry.notes)}` : ''
        } }`)
        .join(',\n')
      }
}`;

  const byKeyLiteral = `{
${([...ENTITY_DOMAINS, ...ASSET_DOMAINS, ...NET_DOMAINS] as readonly RegistryDomain[])
      .map((domain) => {
        const domainEntries = entriesWithDomain.filter((entry) => entry.domain === domain);
        const body = domainEntries.length === 0
          ? '{}'
          : `{
${domainEntries.map((entry) => `      ${JSON.stringify(entry.key)}: ${entry.id}`).join(',\n')}
    }`;
        return `    ${JSON.stringify(domain)}: ${body}`;
      })
      .join(',\n')
    }
  }`;

  const registryListLiteral = `[
  assetRegistries.asset,
  assetRegistries.vfx,
  entityRegistries.card,
  entityRegistries.status,
  entityRegistries.car,
  entityRegistries.deck,
  entityRegistries.track,
  netRegistry
] as const`;

  return [
    `${GENERATED_HEADER}import type { DomainRegistry, RegistryLookupTables } from '../types.js';`,
    "import { assetRegistries } from './assets.gen.js';",
    "import { entityRegistries } from './entities.gen.js';",
    "import { netRegistry } from './net.gen.js';",
    '',
    `const allRegistries = ${registryListLiteral};`,
    '',
    'export const registryLookups = {',
    `  byId: ${byIdLiteral},`,
    `  byKey: ${byKeyLiteral}`,
    '} satisfies RegistryLookupTables;',
    '',
    'export const registriesByDomain = {',
    '  Asset: assetRegistries.asset,',
    '  VFX: assetRegistries.vfx,',
    '  Card: entityRegistries.card,',
    '  Status: entityRegistries.status,',
    '  Car: entityRegistries.car,',
    '  Deck: entityRegistries.deck,',
    '  Track: entityRegistries.track,',
    '  Net: netRegistry',
    "} satisfies Record<DomainRegistry['domain'], DomainRegistry>;",
    '',
    'export const registriesInOrder = allRegistries;',
    ''
  ].join('\n');
}

function generateIndexContent(): string {
  return [
    `${GENERATED_HEADER}export * from './assets.gen.js';`,
    "export * from './entities.gen.js';",
    "export * from './lookups.gen.js';",
    "export * from './net.gen.js';",
    ''
  ].join('\n');
}

async function generate() {
  await ensureDir(generatedDir);

  const domains: RegistryDomain[] = [
    ...ENTITY_DOMAINS,
    ...ASSET_DOMAINS,
    ...NET_DOMAINS
  ];

  const locks = await Promise.all(domains.map((domain) => loadLock(domain)));

  await writeFileIfChanged(path.join(generatedDir, 'entities.gen.ts'), generateEntitiesContent(locks));
  await writeFileIfChanged(path.join(generatedDir, 'assets.gen.ts'), generateAssetsContent(locks));
  await writeFileIfChanged(path.join(generatedDir, 'net.gen.ts'), generateNetContent(locks));
  await writeFileIfChanged(path.join(generatedDir, 'lookups.gen.ts'), generateLookupTables(locks));
  await writeFileIfChanged(path.join(generatedDir, 'index.ts'), generateIndexContent());
}

generate().catch((error) => {
  console.error(error instanceof Error ? error.message : error);
  process.exit(1);
});
